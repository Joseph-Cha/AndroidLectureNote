# 속성(property)

```kotlin
class User7 {
    val age : Int
        get() {
            // 본문
        }
        set(value: Int) {
            
        }
    val name : String
    
    constructor(age: Int, name: String) {
        this.age = age
        this.name = name
    }
}
```

-> 속성: age, name
val user = User7(20, "홍길동")
-> println(user.age) -> 20 출력 -> 코틀린이 getter를 호출해 준다.
user.age = 30 -> 30으로 할당 -> 코틀린이 setter를 호출해 준다.
User7.age = 60 -> 불가능


1. getter/setter
    * getter: 클래스의 속성에 접근할 때
    * setter: 클래스의 속성 값을 설정할 떄
    * 기본적으로 코틀린이 제공을 해주지만, 특별한 기능을 추가하고 싶은 경우에는 개발자가 직접 작성할 수 있다.

2. late init
    ```kotlin
    class User7 {
        lateinit var age : Int
        lateinit var name: String
    }
    ```
   - var로 선언한 프로퍼티에만 적용가능
     - 주 생성자에서는 사용할 수 없다
     - getter/setter 적용이 불가능
     - nullable에는 적용 불가능
     - 기초 타입 프로퍼티에는 적용이 불가능
       - 원시 자료형(primitive type)
       - int(원시 자료형), Int(클래스로된 자료형)
       - 위 2개와 같은 타입은 사용할 수가 없음
       - String을 제외한 우리가 흔히 알고 있는 자료형
     - isInitialized로 초기화 여부를 확인해야 한다.
3. 더블콜론(::)
  - Reflection 기능
  - 런타임에 프로그램의 구조를 주소할 수 있는 기능
  - lateinit의 초기화 여부는 런타임이 아니면 알 수가 없다.
4. lazy
  - 초기화를 미루고 미루고 미뤄서 정말로 필요한(접근할 떄) 순간에 초기화를 하겠다.
  - lazy로 선언된 변수는 선언이 될 때, 혹은 init 블록에서가 아니라 실제로 접근할 때 초기화가 이루어진다.
  - 왜 필요할까?
    - 복잡한 속성을 초기화하는데 많은 코드가 돌아가는 상황에서 사용
    - 특정 속성 값을 당장 사용하지 않는다면 이를 통해 성능상의 이점을 끌어올 수가 있다.

- 목적
    ```
    lateinit 키워드는 코틀린(Kotlin) 프로그래밍 언어에서 사용되며, 주로 지연 초기화(lazy initialization)를 위해 사용됩니다. 
    
    lateinit의 목적과 사용법을 설명하면 다음과 같습니다:
    
    지연 초기화 (Lazy Initialization): lateinit은 변수가 선언될 때가 아니라, 실제로 사용되는 시점에 초기화되어야 할 때 사용됩니다. 이는 특히 의존성 주입이나 유닛 테스팅과 같이 초기화 시점이 늦춰져야 하는 경우에 유용합니다.
    
    널이 아닌 타입 (Non-Nullable Types): 코틀린에서는 기본적으로 모든 타입이 널이 될 수 없습니다. 하지만 실제 초기화가 나중에 이루어져야 하는 경우, lateinit을 사용하면 널 가능 타입을 사용하지 않고도 변수를 선언할 수 있습니다. 이렇게 함으로써 코드에서 널 체크를 줄일 수 있습니다.
    
    성능 향상: 필요할 때까지 객체의 초기화를 지연시킴으로써, 애플리케이션의 성능과 메모리 사용을 최적화할 수 있습니다. 특히 리소스가 많이 필요한 객체의 경우, 이 방식은 매우 유용할 수 있습니다.
    
    사용 조건: lateinit은 기본 타입(primitive types)이 아닌 객체 참조 타입에만 사용할 수 있습니다. 또한, 변수가 var (변경 가능한 변수) 일 때만 사용할 수 있으며, val (변경 불가능한 변수)에는 사용할 수 없습니다.
    
    안전성: lateinit으로 선언된 변수에 접근하기 전에 초기화가 되었는지 확인하는 것은 프로그래머의 책임입니다. 초기화되지 않은 lateinit 변수에 접근하려고 하면 UninitializedPropertyAccessException이 발생합니다.
    
    lateinit은 코드의 유연성을 높이고, 초기화 로직을 제어할 수 있는 강력한 도구입니다. 하지만 초기화 상태를 철저히 관리해야 하며, 오용하면 런타임 오류를 초래할 수 있습니다. 따라서 적절한 사용이 중요합니다.
    ```

## 추가 궁금한 점에 대한 gpt 질의 응답
코틀린에서 사용하는 lateinit을 사용하는 목적에 대해서 설명해 줘.
ChatGPT
lateinit 키워드는 코틀린(Kotlin) 프로그래밍 언어에서 사용되며, 주로 지연 초기화(lazy initialization)를 위해 사용됩니다. lateinit의 목적과 사용법을 설명하면 다음과 같습니다:

지연 초기화 (Lazy Initialization): lateinit은 변수가 선언될 때가 아니라, 실제로 사용되는 시점에 초기화되어야 할 때 사용됩니다. 이는 특히 의존성 주입이나 유닛 테스팅과 같이 초기화 시점이 늦춰져야 하는 경우에 유용합니다.

널이 아닌 타입 (Non-Nullable Types): 코틀린에서는 기본적으로 모든 타입이 널이 될 수 없습니다. 하지만 실제 초기화가 나중에 이루어져야 하는 경우, lateinit을 사용하면 널 가능 타입을 사용하지 않고도 변수를 선언할 수 있습니다. 이렇게 함으로써 코드에서 널 체크를 줄일 수 있습니다.

성능 향상: 필요할 때까지 객체의 초기화를 지연시킴으로써, 애플리케이션의 성능과 메모리 사용을 최적화할 수 있습니다. 특히 리소스가 많이 필요한 객체의 경우, 이 방식은 매우 유용할 수 있습니다.

사용 조건: lateinit은 기본 타입(primitive types)이 아닌 객체 참조 타입에만 사용할 수 있습니다. 또한, 변수가 var (변경 가능한 변수) 일 때만 사용할 수 있으며, val (변경 불가능한 변수)에는 사용할 수 없습니다.

안전성: lateinit으로 선언된 변수에 접근하기 전에 초기화가 되었는지 확인하는 것은 프로그래머의 책임입니다. 초기화되지 않은 lateinit 변수에 접근하려고 하면 UninitializedPropertyAccessException이 발생합니다.

lateinit은 코드의 유연성을 높이고, 초기화 로직을 제어할 수 있는 강력한 도구입니다. 하지만 초기화 상태를 철저히 관리해야 하며, 오용하면 런타임 오류를 초래할 수 있습니다. 따라서 적절한 사용이 중요합니다.

User
lateinit 키워드로 선언된 변수는 그러면 어느 시점에 초기화가 되는 걸까?
ChatGPT
lateinit 키워드로 선언된 변수의 초기화 시점은 프로그래머가 직접 정의하고 제어합니다. 이는 lateinit의 주요 특징 중 하나로, 초기화를 유연하게 관리할 수 있게 해줍니다. 초기화 시점은 다음과 같은 상황에 따라 달라질 수 있습니다:

의존성 주입(Dependency Injection) 시: 객체가 생성된 후 특정 의존성이 주입되는 시점에 초기화될 수 있습니다. 예를 들어, 프레임워크가 객체를 생성한 후 의존성 주입을 통해 필요한 객체를 lateinit 변수에 할당할 때 초기화가 이루어집니다.

생명주기에 따른 초기화: 안드로이드 개발과 같은 경우, 액티비티나 프래그먼트의 생명주기에 따라 초기화가 이루어질 수 있습니다. 예를 들어, onCreate() 또는 onViewCreated() 메서드에서 lateinit 변수를 초기화할 수 있습니다.

사용자 정의 초기화: 프로그래머가 코드 내에서 직접 명시적으로 lateinit 변수를 초기화할 수 있습니다. 이는 특정 메서드 호출 시나 특정 이벤트가 발생했을 때 수행될 수 있습니다.

테스트 케이스에서의 초기화: 단위 테스트 시, 테스트 실행 전에 lateinit 변수를 초기화할 수 있습니다. 이를 통해 테스트 환경에서 필요한 객체나 값으로 쉽게 초기화할 수 있습니다.

lateinit 변수는 초기화되기 전에 접근하려고 하면 UninitializedPropertyAccessException 오류가 발생합니다. 따라서 프로그래머는 lateinit 변수가 적절한 시점에 올바르게 초기화되었는지 관리하는 것이 중요합니다. 또한, 코틀린은 lateinit 변수가 이미 초기화되었는지 확인하는 방법을 제공합니다. 예를 들어, ::변수명.isInitialized 구문을 사용하여 초기화 여부를 확인할 수 있습니다.

User
그러면 결국 값을 할당하는 시점에 초기화가 되는 걸까?
ChatGPT
네, 맞습니다. lateinit 키워드로 선언된 변수는 값을 할당하는 시점에 초기화됩니다. 이는 lateinit의 핵심 기능 중 하나로, 초기화를 지연시킬 수 있게 해주며, 프로그래머가 필요한 시점에 변수에 값을 할당함으로써 초기화를 진행할 수 있습니다.

이러한 특성은 특히 의존성 주입이나 안드로이드의 생명주기 메서드 같은 경우에 유용하게 사용됩니다. 예를 들어, 안드로이드 개발에서는 액티비티나 프래그먼트가 실제로 사용되기 전까지 뷰나 다른 리소스의 초기화를 지연시킬 수 있습니다. 이는 메모리 사용 최적화나 애플리케이션의 성능 향상에 기여할 수 있습니다.

중요한 것은 lateinit 변수에 접근하기 전에 반드시 초기화가 되어야 한다는 점입니다. 초기화되지 않은 lateinit 변수에 접근하려고 하면 UninitializedPropertyAccessException이 발생합니다. 따라서, lateinit 변수를 사용할 때는 초기화 상태를 철저히 관리해야 합니다.

User
만약에 객체에 선언된 속성 값이 3개 존재하는데, 이때 모두 lateinit으로 선언한 4바이트 Int 값이라면,
객체를 생성하는 시점에서 몇 바이트의 메모리를 힙 영역에 할당하게 될까?
그리고 이때 3개 중 1개의 속성 값만 초기화를 한다면 몇 바이트 메모리가 힙에 할당이 될까?
ChatGPT
lateinit 키워드를 사용하여 선언된 속성은 기본적으로 초기화되지 않은 상태로 시작합니다. lateinit은 주로 참조 타입(예: 객체)에 사용되며, 기본 타입(예: Int, Float 등)에는 사용할 수 없습니다. 하지만 이 질문의 맥락에서는 lateinit을 사용할 수 있다고 가정하고 진행하겠습니다.

객체 내에 세 개의 lateinit 속성이 있고, 이들이 각각 4바이트 정수형 (Int)이라고 할 때, 이에 대한 메모리 할당은 다음과 같이 이루어집니다:

객체 생성 시점의 메모리 할당: 객체가 생성될 때, 객체의 메타데이터와 함께 세 개의 속성에 대한 메모리 공간이 할당됩니다. 코틀린에서 Int는 4바이트를 차지합니다. 그러나 lateinit으로 선언된 속성은 참조 타입으로 취급되기 때문에, 실제 메모리 할당은 참조에 필요한 메모리 크기에 따라 달라집니다. 이는 JVM이나 플랫폼에 따라 다를 수 있습니다.

속성 값 초기화 시의 추가 메모리 할당: lateinit 속성 중 하나만 초기화되었다면, 그 속성에 대한 실제 값(4바이트 Int 값)이 메모리에 할당됩니다. 다른 두 속성은 여전히 초기화되지 않은 상태이므로, 추가적인 메모리 할당은 발생하지 않습니다.

정리하자면, 객체가 생성될 때 세 개의 lateinit 속성에 대한 참조 메모리가 할당됩니다. 그 후, 속성 중 하나가 초기화될 때 해당 값의 메모리 할당이 이루어집니다. 그러나 이러한 메모리 할당의 정확한 크기는 JVM의 구현, 객체 헤더의 크기, 참조 변수에 대한 메모리 할당 정책 등에 따라 달라질 수 있으며, 일반적으로 Int 타입의 크기인 4바이트보다 클 수 있습니다.

User
좀 더 컴퓨터 구조 이론 관점에서 어려운 질문을 하려고 해.
가령 아래와 같은 class를 코틀린에서 생성한다고 가정해 보자.

``` kotilin
class User {
     lateinit var age: Int
     lateinit var score: Int
     lateinit var phoneNumber: Int
}
```
그리고 아래와 같이 User 객체를 생성한다고 해보자.

``` kotilin
var user1 = User()
```

이때 user1이 가리키고 있는 heap 영역의 메모리의 크기는 얼마일까?
lateinit이 말 그대로 객체가 생성되는 시점에 초기화가 되는 게 아니라 속성 값을 할당할 때 메모리가 할당이 되는 거라면, user1은 그저 User 객체의 시작 주소만 들고 있을 뿐일 것이고, 실제 user1이 가리키고 있는 메모리 영역에 갔을 때 빈 값이 있어야 할 것으로 예상 돼.

내가 이야기한 게 맞다면 이어서 또 궁금한 게 있어.
만약 user1이 가리키고 있는 heap 영역이 시작 주소에서 4바이트 다음 공간에 값이 쓰인다면 어떻게 될까?
그러면 user1에서 score 변수를 초기화할 때 이미 해당 영역은 값이 쓰여 있기 때문에 문제가 될 것 같아서.
ChatGPT
코틀린에서 lateinit 키워드를 사용하는 경우와 객체의 메모리 할당에 대해 이해하려는 시도는 매우 흥미롭지만, 몇 가지 중요한 점을 명확히 해야 합니다.

먼저, lateinit은 참조 타입(예: 클래스, 인터페이스)에 대한 지연 초기화를 위해 사용되며, 기본 타입(예: Int, Float)에는 사용할 수 없습니다. 따라서, 제시된 User 클래스 예시는 코틀린에서 유효하지 않습니다. 하지만, 이론적인 관점에서 질문에 답하기 위해 lateinit을 기본 타입에 사용할 수 있다고 가정하겠습니다.

User 객체의 메모리 할당: User 객체가 생성될 때, JVM(Java Virtual Machine)은 User 객체를 위한 메모리를 할당합니다. 이 메모리에는 객체의 메타데이터(예: 타입 정보, 가비지 컬렉션 정보 등), 그리고 객체의 필드에 대한 참조들이 포함됩니다. lateinit으로 선언된 필드들은 초기화되지 않은 상태로 남아있으며, 실제 기본 타입 값(예: Int)에 대한 메모리는 아직 할당되지 않았습니다. lateinit은 해당 필드에 대한 참조 자리를 마련하되, 실제 값은 나중에 할당됩니다.

Heap 영역과 lateinit: user1 객체가 생성되면, 이 객체는 힙(heap) 영역에 할당됩니다. 이 객체는 클래스의 인스턴스 필드에 대한 참조들을 포함하지만, lateinit으로 선언된 필드들은 아직 초기화되지 않았으므로, 이러한 필드들에 대한 실제 값은 아직 할당되지 않은 상태입니다.

메모리 충돌 시나리오: user1이 가리키는 힙 영역의 특정 주소에서 이미 값이 존재하는 경우, 이는 정상적인 상황이 아닙니다. 객체의 필드는 해당 객체의 메모리 영역 내에서 관리되며, JVM은 이러한 메모리 할당을 안전하게 관리합니다. lateinit으로 선언된 필드에 값을 할당하면, 해당 필드가 참조하는 메모리 위치에 새로운 값이 저장됩니다. 이미 사용 중인 메모리 영역에 임의로 접근하거나 값을 할당하는 것은 JVM의 메모리 관리 정책에 위배됩니다.

결론적으로, lateinit 변수는 초기화되지 않은 상태에서는 해당 변수를 위한 참조 공간만을 갖습니다. 이러한 변수를 초기화할 때, 즉 값을 할당할 때 해당 메모리 영역에 실제 값이 저장됩니다. JVM은 객체의 메모리 할당과 관리를 안전하게 처리하므로, 다른 객체나 메모리 영역과의 충돌은 발생하지 않습니다.

User
내가 작성한 이유 때문에 기본 타입은 lateinit을 사용하지 않는 게 아닐까?
ChatGPT
네, 맞습니다. lateinit 키워드는 코틀린에서 기본 타입(primitive types)에 사용할 수 없는 이유 중 하나는 여러분이 언급한 메모리 관리와 관련된 이슈 때문입니다. lateinit의 주된 목적과 사용하는 이유를 간략하게 살펴보면 다음과 같습니다:

참조 타입에 대한 지연 초기화: lateinit은 참조 타입에 대한 지연 초기화를 가능하게 합니다. 이는 객체 생성 시점과 실제 사용 시점 사이에 시간 간격이 있을 때 유용합니다. 예를 들어, 의존성 주입이나 UI 요소의 초기화 등이 이에 해당합니다.

널이 아닌 타입 보장: lateinit을 사용함으로써 널이 아닌(non-nullable) 타입을 보장할 수 있습니다. 이는 널 가능성을 줄이고, 코드의 안전성을 높이는 데 도움이 됩니다.

메모리 관리: 기본 타입은 값(value) 타입으로, 메모리에 직접 값을 저장합니다. 반면, 참조 타입은 객체에 대한 참조(reference)를 저장합니다. lateinit은 참조 타입에 대한 참조를 저장하고, 나중에 실제 객체가 할당될 때까지 초기화를 지연시킵니다. 기본 타입에는 이런 방식의 지연 초기화가 필요하지 않으며, 기본 타입은 미리 정의된 고정 크기를 가지고 있어 메모리 관리가 더 단순합니다.

메모리 안정성: 기본 타입에 lateinit을 사용하면, 초기화되지 않은 상태에서 메모리에 접근할 수 있는 위험이 생깁니다. 이는 프로그램의 안정성을 해칠 수 있으며, 예기치 못한 오류를 발생시킬 수 있습니다. 따라서, lateinit은 안정성을 위해 참조 타입에만 제한적으로 사용됩니다.

이러한 이유로, 코틀린에서는 lateinit을 참조 타입에만 사용하고, 기본 타입에는 사용하지 않습니다. 기본 타입은 항상 초기값을 가지고 있어야 하며, 이는 코틀린의 타입 안전성과 일관성을 유지하는 데 도움이 됩니다.





